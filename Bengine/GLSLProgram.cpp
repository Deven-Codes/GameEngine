#include "GLSLProgram.h"

namespace Bengine {
	GLSLProgram::GLSLProgram() : _numAttributes(0),
		_programID(0),
		_vertexShaderID(0),
		_fragmentShaderID(0)
	{

	}

	GLSLProgram::~GLSLProgram()
	{

	}

	void GLSLProgram::compileShaders(const std::string& vertexShaderFilePath, const std::string& fragmentShaderFilePath)
	{
		/*
		 * glCreateProgram(): creates an empty program object and return a non-zero value
		 *                   by which it can be referenced.
		 *
		 * A program object is an object to which shader objects can be attached.
		 * This provides a mechanism to specify the shader objects that will be linked to create a program.
		 * It also provides a means for checking compatibility of the shaders that will be used to create a program.
		 * For instance, checking the compatibility between a vertex shader and a fragment shader.
		 * When no longer nedded as part object shader objects can be detached.
		 *
		 */
		_programID = glCreateProgram();

		/*
		 * glCreateShader(): creates an empty shader object and returns a non-zero value
		 *                   by which it can be referenced.
		 *					 This function returns 0 if an error occurs creating the shader object.
		 *                   GL_INVALID_ENUM is generated if shaderType is not an accepted value
		 *
		 * A shader object is used to maintain the source code string that define a shader.
		 * Five type of shader are supported
		 *
		 * GL_COMPUTE_SHADER: Shader that is intented to run on the programmable compute processor.
		 * GL_VERTEX_SHADER: shader that is intended to run on the programmable vertex processor.
		 * GL_TESS_CONTROL_SHADER: Shader that is intended to run on the programmable tessellation processor in the control stage.
		 * GL_TESS_EVALUATION_SHADER: Shader that is intended to run on the programmable tessellation processor in the evaluation stage
		 * GL_GEOMETRY_SHADER: Shader that is intended to run on the programmable geometry processor.
		 * GL_FRAGMENT_SHADER: Shader that is intended to run on the programmable fragment processor.
		 *
		 */
		_vertexShaderID = glCreateShader(GL_VERTEX_SHADER);
		if (_vertexShaderID == 0) {
			fatalError("Vertex Shader failed to be created!");
		}

		_fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);
		if (_fragmentShaderID == 0) {
			fatalError("Fragment Shader failed to be created");
		}

		compileShader(vertexShaderFilePath, _vertexShaderID);
		compileShader(fragmentShaderFilePath, _fragmentShaderID);
	}

	void GLSLProgram::compileShader(const std::string& filePath, GLuint id)
	{
		/*
		 * Creating a ifstream object
		 */
		std::ifstream vertexFile(filePath);

		/*
		 * Error checking for ifstream object
		 */
		if (vertexFile.fail()) {
			perror(filePath.c_str());
			fatalError("Failed to open " + filePath);
		}

		/*
		 * fileContents: store shader source code string
		 */
		std::string fileContents = "";

		/*
		 * line: reads string from vertexFile
		 */
		std::string line;

		/*
		 * Reads from vertexFile into "line" till eof and concatenate "line" + "\n" to "fileContents"
		 */
		while (std::getline(vertexFile, line)) {
			fileContents += line + "\n";
		}

		/*
		 * Close ifstream object
		 */
		vertexFile.close();

		/*
		 * Create a const char* to store fileContents
		 */
		const char* contentPtr = fileContents.c_str();

		/*
		 * glShaderSource(GLuint shader, GLsize count,	const GLchar **string, const GLint *length):
		 *
		 * glShaderSource(): Replaces the source code in the shader object (id) to the source code in the
		 *					 array of strings (contentPtr).
		 *                   Any source code previously stored in shader is completely replaced.
		 *                   The number of strings in the array is specified by count.
		 *                   If the length is NULL each string is assumed to be null terminated.
		 *                   If length is a value other than NULL, it points to an array caontaining a string length
		 *                   for each of the corresponding elements of strings.
		 *                   Each element in the length array may contain length of corresponding string
		 *                   The NULL character or value less than 0 in length array indicates that the string is null terminated
		 *
		 * The source code strings are not parse or scanned at this point they are simply copied into the shader object
		 *
		 * Note: OpenGL copies the shader source code strings when glShaderSource is called,
		 *       so an application may free its copy of the source code strings immediately after the function returns.
		 *
		 * GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
		 * GL_INVALID_OPERATION is generated if shader is not a shader object.
		 * GL_INVALID_VALUE is generated if count is less than 0.
		 *
		 */
		glShaderSource(id, 1, &contentPtr, nullptr);

		/*
		 * glCompileShader(): Compiles the source code strings that have been stored in the shader object(id) specified by shader.
		 *
		 * The compilation status will be stored as part of the shader object's state.
		 * This value will be set to GL_TRUE if the shader was compiled without errors and is ready for use, and GL_FALSE otherwise.
		 * It can be queried by calling glGetShader with arguments shader and GL_COMPILE_STATUS.
		 */
		glCompileShader(id);

		int isCompiled = 0;

		/*
		 * glGetShaderiv(): Returns a parameter from a shader object
		 *
		 * The following parameters are defined:
		 *
		 * GL_SHADER_TYPE: params returns GL_VERTEX_SHADER if shader is a vertex shader object,
		 *                 GL_GEOMETRY_SHADER if shader is a geometry shader object,
		 *   			   GL_FRAGMENT_SHADER if shader is a fragment shader object.
		 *
		 * GL_DELETE_STATUS: params returns GL_TRUE if shader is currently flagged for deletion, and GL_FALSE otherwise.
		 *
		 * GL_COMPILE_STATUS: params returns GL_TRUE if the last compile operation on shader was successful, and GL_FALSE otherwise.
		 *
		 * GL_INFO_LOG_LENGTH: params returns the number of characters in the information log for shader
		 *                     including the null termination character (i.e., the size of the character buffer required to store the information log).
		 *                     If shader has no information log, a value of 0 is returned.
		 *
		 * GL_SHADER_SOURCE_LENGTH: params returns the length of the concatenation of the source strings that make up the shader source for the shader,
		 *                          including the null termination character. (i.e., the size of the character buffer required to store the shader source).
		 *                          If no source code exists, 0 is returned.
		 *
		 */
		glGetShaderiv(id, GL_COMPILE_STATUS, &isCompiled);

		/*
		 * Checking is Shader compiles successfully
		 */
		if (isCompiled == GL_FALSE)
		{
			int maxLength = 0;
			glGetShaderiv(id, GL_INFO_LOG_LENGTH, &maxLength);

			// The maxLength includes the NULL character
			std::vector<GLchar> errorLog(maxLength);

			/*
			 * RETURN VALUE The alloca() function returns a pointer to the beginning of the allocated space.
			 * If the allocation causes stack overflow, program behaviour is undefined.
			 */
			 //char* errorLog = (char*)alloca(maxLength * sizeof(char));


			 /*
			  * glGetShaderInfoLog(): returns the information log for the specified shader object.
			  *                       The information log for a shader object is modified when the shader is compiled.
			  *                       The string that is returned will be null terminated.
			  */
			glGetShaderInfoLog(id, maxLength, &maxLength, &errorLog[0]);




			/*
			 * glDeleteShader(): Deletes a shader object
			 *
			 * Frees the memory and invalidates the name associated with the shader object specified by shader
			 * This command effectively undoes the effects of a call to glCreateShader()
			 *
			 * If a shader object to be deleted is attached to a program object, it will be flagged for deletion,
			 * but it will not be deleted until it is no longer attached to any program object,
			 * for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted).
			 * A value of 0 for shader will be silently ignored.
			 *
			 * To determine whether an object has been flagged for deletion, call glGetShader with arguments shader and GL_DELETE_STATUS.
			 */
			glDeleteShader(id); // Don't leak the shader.

			std::printf("%s\n", &(errorLog[0]));
			fatalError("Shader" + filePath + " failed to compile");
		}
	}

	void GLSLProgram::linkShaders()
	{
		/*
		 * glAttachShader(): Attaches a shader object to program object
		 *
		 * Program object provides the mechanism  to specify the list of things that will be linked togeather
		 *
		 * Shaders that are going to be linked togeather in a program object must first attached to the program object.
		 * glAttachShader() attaches the shader object specified by shader to the program object specified by program.
		 * This indicates that shader will be included in link operations that will be performed on program.
		 *
		 * All operations that can be performed on a shader object are valid whether or not the shader object is attached tp a program object.
		 * It is permissible to attach a shader object to a program object before source code has been loaded or shader object has been compiled.
		 * It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader.
		 * It is also permissible to attach a shader object to more than one program object.
		 * If a shader object is deleted while it is attached to a program object, it will be flagged for deletion.
		 */
		glAttachShader(_programID, _vertexShaderID);
		glAttachShader(_programID, _fragmentShaderID);

		/*
		 * glLinkProgram(): Links a program object
		 *
		 * The status of the link operation will be stored as part of the program object's state.
		 * This value will be set to GL_TRUE if the program object was linked without errors and is ready for use, and GL_FALSE otherwise.
		 * It can be queried by calling glGetProgram with arguments program and GL_LINK_STATUS.
		 *
		 * As a result of a successful link operation, all active user-defined uniform variables belonging to program will be initialized to 0,
		 * and each of the program object's active uniform variables will be assigned a location that can be queried by calling glGetUniformLocation.
		 * Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index
		 * will be bound to one at this time.
		 *
		 * Documentation Link: http://docs.gl/gl4/glLinkProgram
		 */
		glLinkProgram(_programID);

		// Note the different functions here: glGetProgram* instead of glGetShader*.
		int isLinked = 0;

		/*
		 * glGetProgram(): returns in params the value of a parameter for a specific program object.
		 *
		 * Documentation Link:http://docs.gl/gl4/glGetProgram
		 */
		glGetProgramiv(_programID, GL_LINK_STATUS, (int*)&isLinked);
		if (isLinked == GL_FALSE)
		{
			int maxLength = 0;
			glGetProgramiv(_programID, GL_INFO_LOG_LENGTH, &maxLength);

			// The maxLength includes the NULL character
			std::vector<GLchar> infoLog(maxLength);

			/*
			 * glGetProgramInfoLog(): returns the information log for the specified program object.
			 *                        The information log for a program object is modified when the program object is linked or validated.
			 *                        The string that is returned will be null terminated.
			 */
			glGetProgramInfoLog(_programID, maxLength, &maxLength, &infoLog[0]);

			/*
			 * glDeleteProgram frees the memory and invalidates the name associated with the program object specified by program.
			 * This command effectively undoes the effects of a call to glCreateProgram.
			 *
			 * If a program object is in use as part of current rendering state, it will be flagged for deletion,
			 * but it will not be deleted until it is no longer part of current state for any rendering context.
			 * If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached
			 * but not deleted unless they have already been flagged for deletion by a previous call to glDeleteShader. A value of 0 for program will be silently ignored.
			 */

			 // We don't need the program anymore.
			glDeleteProgram(_programID);
			// Don't leak shaders either.
			/*glDeleteShader(_vertexShaderID);
			glDeleteShader(_fragmentShaderID);*/

			// Use the infoLog as you see fit.

			std::printf("%s\n", &(infoLog[0]));
			fatalError("Shader failed to link!");
		}

		/*
		 * glDetachShader(): Detaches a shader object from a program object to which it is attached
		 *
		 * glDetachShader detaches the shader object specified by shader from the program object specified by program.
		 * This command can be used to undo the effect of the command glAttachShader.
		 *
		 * If shader has already been flagged for deletion by a call to glDeleteShader and it is not attached to any other program object,
		 * it will be deleted after it has been detached.
		 */

		 // Always detach shaders after a successful link.
		glDetachShader(_programID, _vertexShaderID);
		glDetachShader(_programID, _fragmentShaderID);

		// Deletes shaders
		glDeleteShader(_vertexShaderID);
		glDeleteShader(_fragmentShaderID);
	}

	void GLSLProgram::addAttribute(const std::string& attributeName)
	{
		/*
		 * glBindAttribLocation(): Associates a generic vertex attribute index with a named attribute variable
		 *
		 * Documentation link: http://docs.gl/gl4/glBindAttribLocation
		 */
		glBindAttribLocation(_programID, _numAttributes++, attributeName.c_str());
	}

	void GLSLProgram::use()
	{
		/*
		 *  glUseProgram(): installs the program object specified by program as part of current rendering state.
		 *                  One or more executables are created in a program object by successfully attaching shader objects to it with glAttachShader,
		 *    successfully compiling the shader objects with glCompileShader, and successfully linking the program object with glLinkProgram.
		 *
		 * Documentation link: http://docs.gl/gl4/glUseProgram
		 */
		glUseProgram(_programID);
		for (int i = 0; i < _numAttributes; i++) {

			/*
			 * glEnableVertexAttribArray() and glEnableVertexArrayAttrib() enable the generic vertex attribute array specified by index.
			 *
			 * glEnableVertexAttribArray() uses currently bound vertex array object for the operation,
			 * whereas glEnableVertexArrayAttrib() updates state of the vertex array object with ID vaobj.
			 *
			 */
			glEnableVertexAttribArray(i);
		}
	}

	void GLSLProgram::unuse()
	{
		// 0 specifies that we are not using any program or program object is 0. 
		glUseProgram(0);
		for (int i = 0; i < _numAttributes; i++) {

			/*
			 * glDisableVertexAttribArray() and glDisableVertexArrayAttrib() disable the generic vertex attribute array specified by index.
			 * glDisableVertexAttribArray() uses currently bound vertex array object for the operation,
			 * whereas glDisableVertexArrayAttrib() updates state of the vertex array object with ID vaobj.
			 */
			glDisableVertexAttribArray(i);
		}
	}

	GLint GLSLProgram::getUniformLocation(const std::string& uniformName)
	{
		GLint location = glGetUniformLocation(_programID, uniformName.c_str());
		if (location == GL_INVALID_VALUE) {
			fatalError("Uniform: " + uniformName + " not found in shader!");
			return 0;
		}
		return location;
	}
}